---
layout: page
title: 재현가능한 과학적 분석을 위한 중급 R 
subtitle: data.table
minutes: 20
---


> ## 학습 목표 {.objectives}
>
> * `data.table`을 사용해서 일반적인 데이터프레임 작업을 수행하는 방법을 이해한다.
> * R에서 객체 구조를 면밀히 조사하는 방법을 이해한다.
> * `data.table`에 대한 키를 설정한다.
>

먼저 `data.table` 팩키지를 학습한다. 데이터테이블은 데이터프레임에 대해 몇가지 장점이 있다:

 * 데이터프레임보다 속도가 엄청 빠르다. 데이터프레임으로 몇시간 소요되는 작업이 데이터테이블로 몇초면 해결된다.
 * 코드를 더 간결하게 작성하도록 해서, 복잡한 문장과 반복되는 부분집합 연산을 회피할 수 있다.
 * 데이터테이블 키를 사용해서 행명칭(rownames)을 매칭하는 걱정없이, 다수 테이블을 병합/쿼리할 수 있다.

### 데이터 불러 읽어오기

팩키지를 불러 읽어올리고, 데이터를 불러 읽어온다:

```{r}
library("data.table")
gap <- fread("data/gapminder-FiveYearData.csv")
gap
```

`data.table` 팩키지로부터 `fread` 함수를 사용해서 올바르게 데이터를 불러 읽어온 것을 
확인할 수 있다.
데이터프레임과 달리, R이 자동으로 테이블에서 첫째와 마지막 행 5개를 출력한다.

`fread`는 `read.table`과 유사하게 작동한다: 데이터에서 의미를 유추해서 적절히
데이터를 불러오려 최대한 노력한다. 큰 테이블의 경우 `fread`가 `read.table` 보다 훨씬 더 빠르지만,
정교함은 약간 떨어진다. 데이터를 올바르게 불러오는데 있어 `read.table` 함수 혹은 파생된 함수를 사용하고 나서, 데이터테이블로 던져 처리한다:

```{r}
# data.table 함수는 'keep.rownames = TRUE' 설정을 하지 않으면,
# 행명칭(rownames)를 버려버린다.
gap_df <- read.csv("data/gapminder-FiveYearData.csv")
gap_dt2 <- as.data.table(gap_df)
```

구조함수(`str`) 함수를 사용해서, `data.table`이 정확하게 무엇으로 구성되었는지 면밀히 조사한다:

```{r}
str(gap)
```

`data.table`은 단순히 데이터프레임에 추가적인 클래스가 부착되어 있다. ".internal.selfref" 라는 특수 속성도 함께 있는데, 이는 저수준 언어로 메모리에 데이터를 작업하는데 `data.table`이 사용하는 외부 포인터다.

데이터테이블은 데이터프레임을 필요로 하는 함수 대부분과 (이전 버젼과) 호환성(backwards compatible)을 유지한다. 하지만, 경우에 따라서는 객체 첫 클래스만 검사하는 함수에 대해 `as.data.frame`을 사용할 필요도 있다.

상기 내용을 증명하는데, 객체 동치성을 검사한다:

```{r}
all.equal(gap, gap_df)
all.equal(gap, gap_df, check.attributes = FALSE)
```

상기 메시지가 객체 속성은 다르지만, 밑에 깔린 데이터는 동일함을 보여주고 있다.


### 기본 연산

데이터테이블에 거의 모든 연산은 `[` 함수 내부에서 실행되고, 
메모리 위 그자리에서 실행된다. 
연산 일부를 살펴보고, 데이터프레임과 동등한지도 함께 알아보자:

행을 선택하거나 필터링할 때, 데이터프레임과 마찬가지로 `[` 함수의 첫번째 인자를 사용한다:

```{r}
gap[continent == "Oceania"]
# 데이터프레임 대응표현
gap_df[gap_df$continent == "Oceania",]
```

The data table knows when we type `continent` to look for that as a column in
the table: removing the redundant text we'd need to type for data.frames. This 
becomes even more convenient when filtering on multiple columns:

```{r}
gap[continent == "Oceania" & country == "Australia" & year %in% c(1952, 2007)]
# 데이터프레임 대응표현
gap_df[gap_df$continent == "Oceania" & gap_df$country == "Australia" & gap_df$year %in% c(1952, 2007),]
```

Note that the data frame call will still work on the data table:

```{r}
gap[gap$continent == "Oceania" & gap$country == "Australia" & gap$year %in% c(1952, 2007),]
```

To select columns we use the second argument to `[`, just like data.frames:

```{r}
gap[,continent]
# data frame equivalent
gap_df[,"continent"]
```

To select multiple columns, we need to pass in the column names as a list:

```{r}
gap[, list(continent, country, pop)]
# data frame equivalent
gap_df[, c("continent", "country", "pop")]
```

We can also rename columns in the output using the list:

```{r}
gap[, list(a=continent, b=country, c=pop)] # This does not alter the data table
```

We can create temporary columns, those that only exist in the output data 
structure using list arguments:

```{r}
# total_gdp only exists in the output
gap[,list(continent, country, year, total_gdp=pop*gdpPercap)]
# Lets see what gap contains again:
gap
# The equivalent data frame call:
cbind(gap_df[,c("continent", "country", "year")], total_gdp = gap_df$pop * gap_df$gdpPercap)
```

To create a new column in the data table, we have to use the special operator 
`:=`:

```{r}
# Add a new column to the gapminder data with total gdp
gap[, total_gdp := gdpPercap * pop]
# data frame equivalent
gap_df <- cbind(gap_df, total_gdp = gap_df$gdpPercap * gap_df$pop)
```

To delete a column, we assign it `NULL`

```{r}
# Delete the total_gdp column
gap[, total_gdp := NULL]
# data frame equivalent
gap_df <- gap_df[, -which(names(gap_df) == "total_gdp")]
```

### Data table specific operations

Data tables have a number of special variables that are useful in calculations:

```{r}
# get all the columns
gap[,.SD]
# get the number of rows
gap[,.N]
# generate indices for the rows
gap[,.I]
```

These become useful in conjuction with data table's extra arguments to `[`:

```{r}
# How many countries in each continent?
gap[year == 2007, list(countries=.N), by=continent]
```

The `by` argument lets you calculate things within groups:

```{r}
# Mean life expectancy per continent per year:
gap[, list(avgLifeExp=mean(lifeExp)), by=list(continent, year)]
```

The `with` argument lets you pass in column names as a character vector:

```{r}
gap[,c("continent", "country", "year"), with=FALSE]
```

### Keys 

One of the advantages of data table is the ability to set each tables "keys":
the columns which will act as unique identifiers for each row, for example:

```{r}
setkey(gap, continent, country, year)
```

We can see the change using the `tables` function, which shows all data tables 
in the R session:

```{r}
tables()
```

This is really useful when you have multiple tables: allowing you to efficiently
merge tables together, confidently and concisely:

```{r}
landSize <- data.table(
  country=c("Australia", "New Zealand"),
  size=c(7692024, 268021)
)
setkey(landSize, country)
setkey(gap, country)
# Join landSize to gap, keeping only 'keys' (rows) in gap that also exist in
# landSize
gap[landSize]
# And vice-versa:
landSize[gap]
```

To learn more about data table, you can check out the package Vignette on CRAN:
<http://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.pdf> 




